# Automating your analyses and executing long-running analyses on remote computers

This two hour workshop will show attendees how to automate their
analyses using shell scripts, as well as run and manage software that
takes minutes, hours, or days to execute. We’ll also show you how to
disconnect from and resume running processes using the ‘screen’ and 'tmux'
commands.


This lesson was adopted from [a lesson](https://github.com/ngs-docs/2021-GGG298/tree/latest/Week8-project_organization_and_UNIX_shell#file-manipulation) co-authored by Shannon Joslin for GGG 298 at UC Davis.

Learning objectives:

- how to write and execute shell scripts
- commands `if`, `for`, `basename`, `echo`
- learning how to use multiple screens



## What is a script?

- intro to what a "shell script" is
   - we're teaching how to make shell scripts today, but scripts can be in any programming language (R, python, etc.)
- why/when we want to use scripts vs. typing commands directly at the terminal
   - automate: don't have to remember all the commands and type then one at a time
   - scale up: can use same script for multiple samples, multiple processes
   - reproduce/share: easier to reproduce or share analyses because it's all written down
   - ...


## Getting started

As per the instructions in [workshop
3](connecting-to-remote-computers-with-ssh.html) and [workshop
4](running-programs-on-remote-computers-and-retrieving-the-results.html),
log into farm.cse.ucdavis.edu using your datalab-XX account.

When you log in, your prompt should look like this:

> ~~~
> (base) datalab-09@farm:~$
> ~~~

If it doesn't, please alert a TA and we will help you out!

## Automating commands by putting them in a text file

- demo same set of commands run in terminal vs. putting into a text file
  - mention how to look up terminal history (`history`)
  - review content from workshop 2 on creating & modifying text files
  - in practice, the process is: make file, edit, save, test run, edit, save, re-run, ...
- note that commands are executed in the order that they appear in the script
- something about file extensions (`.sh`, ...)

### Running scripts with `bash`

- running it with 'bash' explicitly
  - i.e., `./myscript.sh` vs. `bash myscript.sh`
- run sets of commands in a script but not in loops yet - do that in section below



At the terminal, we can type:
```
echo Hello, this is the terminal!
```

In a script, we can do the same thing:
```
# create a script file with nano
nano first_script.sh

# add this to the script
echo Hello this is a script!

# execute the script
bash first_script.sh
```



### Bash script headers and permissions

- putting a header in and changing permissions; executing via shell prompt
  - read access to run it, execute access to run it with the shebang, write access to see it in the dir?
  - `#!/bin/bash` header




## `for` Loops


a loop to create list of md5sum fingerprints for the mini-A-torda .fna.gz files:
```
(base) datalab-02@farm:~/seqdata/mini_A-torda$ for i in *.fna.gz; do echo md5sum $i; done

# now, let's append those md5sum numbers to a text file
(base) datalab-02@farm:~/seqdata/mini_A-torda$ for i in *.fna.gz; do md5sum $i >> my_md5sum_list.txt;done
(base) datalab-02@farm:~/seqdata/mini_A-torda$ less my_md5sum_list.txt
```



- intro to `for` loops in scripts
   - discuss indentation in loop structure, or use `;`
   - using `echo`: to print statements, to check what command is being run before actually running it
   - discuss what the `$` syntax means, i.e., `$i`, `${i}`, and `$(...)`
   - for loop structure ends with `done`
- material below from workshop 1 notes - review (if taught in previous workshop) and show how to put it into a shell script file:

```
for i in *.fastq
do
   echo $i
done
```

This is running the command `echo` for every value of the variable 'i', which is set (one by one) to all the values in the expression `*.fastq`.

If we want to get rid of the extension '.fastq', we can use the `basename` command:

```
for i in *.fastq
do
   basename $i .fastq
done
```

Now, this doesn't actually rename the files - it just prints out the name, with the suffix '.fastq' removed.  To rename the files, we need to capture the new name in a variable:

```
for i in *.fastq
do
   newname=$(basename $i .fastq).fq
   echo $newname
done
```

What `$( ... )` does is run the command in the middle, and then replace the `$( )` with the output of running the command.

_Side note:_ you may see backquotes used instead of `$(...)`. It does the same thing but is trickier to get right, so we teach `$(...)` instead of `` `...` ``.

Now we have the old name (`$i`) and the new name (`$newname`) and we're ready to write the rename command --

```
for i in *.fastq
do
   newname=$(basename $i .fastq).fq
   echo mv $i $newname
done
```

**Question:** why did we put `echo` here?


**not sure want to run this - because then it's harder to go back to original file name...**

>Now that we're pretty sure it all looks good, let's run it for realz:

>```
>for i in *.fastq
>do
>   newname=$(basename $i .fastq).fq
>   mv $i $newname
>done
>```

**Challenge**

Run the same loop in a shell script called `rename_file.sh`.

### Variables:

You can use either $varname or ${varname}.  The latter is useful when you want to construct a new filename, e.g.

```
MY${varname}SUBSET
```

would expand ${varname} and then put MY .. SUBSET on either end, while

```
MY$varnameSUBSET
```

would try to put MY in front of $varnameSUBSET which won't work.

(Unknown/uncreated variables are empty.)

NOTE: `${varname}` is quite different from `$(expression)`! The former is replaced by the value assigned to `varname`; the latter is replaced by the result of running `expression`. So, both _replace_ but they do different things. Think of `$` here as meaning, "replace me with something".



**Question:** We used "\$varname" above - what happens if we use single quotes - e.g. '$varname'?

(Variables are interpreted inside of "", and not inside of ''.)




## Troubleshooting scripts

- what happens on failure; `set -e` and `set -x`
  - interpreting error messages
  - as another example of `set` options, could mention adding `set -o noclobber` to prevent overwriting in bash script too (was mentioned in workshop 2 as a way to prevent overwriting `echo this is a file > file.txt` and `echo this is more text > file.txt`)


### Practicing `set -e` in bash scripts

> 1. download some small fastq files - currently using example MiSeq files from binder
> 2. install some software (i.e., FastQC with `conda` or `mamba` --> these are covered in Workshop 5; remember to config channels!)
> 3. loop through samples and run fastqc with bash script

```
# create output report directory
mkdir ./data/fastqc_reports

# create bash script using nano text editor
# save and exit with ctrl-o, enter, ctrl-x on keyboard
nano set_e.sh
```

Create a bash script with the following commands, this version includes `set -e`:

```
#!/bin/bash

set -e

OUTDIR='fastqc_reports'

for i in ./data/MiSeq/*.fastq
do
   echo $i
   fastqc $i -o $OUTDIR
done
```

Another way to type bash `for` loops is with the `;`, for example this syntax does the same thing as above:

```
for i in ./data/MiSeq/*.fastq; do echo $i; fastqc $i -o $OUTDIR; done
```

This command runs the script:

```
bash set_e.sh
```

**CHALLENGE**

1. What happens when you run the bash script above **with** and **without** the `set -e` option?
2. There is an error in the bash script. How can you fix the script? (Bonus: try adding `set -x` to your bash script)





## If statements

- an intro to scripts with conditions
  - conditional operators in Unix (not all the same as other programming languages)
  - if/then/else/elif statements > i.e., if file exists, do this. if file doesn't, do that.
  - discuss indentation, or use `;`
  - conditional statement structure ends with `fi`


Let’s go back to the ‘data’ directory and play around with loops some more.



- here, we're wrapping if statements in a for loop  

```
for i in *
do
   if [ -f $i ]; then
      echo $i is a file
   elif [ -d $i ]; then
      echo $i is a directory
   fi
done
```

but what the heck is this `[ ]` notation? That's actually running the 'test' command; try `help test | less` to see the docs. This is a weird syntax that lets you do all sorts of useful things with files -- I usually use it to get rid of empty files.

```
touch emptyfile.txt
```

to create an empty file, and then:

```
for i in *
do
   if [ \! -s $i ]; then
      echo rm $i
   fi
done
```

...and as you can see here, I'm using '!' to say 'not'. (Why do I need to put a backslash in front of it, though??)







Create a bash script called `ifs.sh` that uses if statements to compare 2 numbers:

```
#!/bin/bash

a=40
b=20

if [ $a != $b ]
then
  echo 'a is not equal to b!'
else
  echo 'a is equal to b!'
fi
```

**Question**

Try replacing the `!=` operator with [other conditional operators](https://www.tutorialspoint.com/unix/unix-basic-operators.htm) (i.e., `==`). Be sure to edit the echo statements!







### Running scripts in a loop

We can run loops in scripts AND scripts in loops!

Let's edit the ifs.sh script and give it arguments. Instead of editing the values for "a" and "b" in the script, we'll create "a" and "b" arguments so we can change them when executing the script.

Here's how we change the script - `$` and the number assigns the argument a position in the line of code.


```
#!/bin/bash

a=$1
b=$2

if [ $a != $b ]
then
  echo 'a is not equal to b!'
else
  echo 'a is equal to b!'
fi
```

After the `bash <script name>`, the syntax now assigns the 1st element (`$1`) to `40` and the 2nd element (`$2`) to `20`. This means you can enter different numbers when executing the script, without needing to edit the script file at all!

```
bash ifs.sh 40 20
```

**Challenge:** How might you put this script in a `for` loop?




## Multiple screens

Say you want to run multiple scripts at once, or you want to put your computer to sleep and check back later, what can you do?

- introducing `screen` and `tmux`  --> demo utility
   - when do you use screen vs. tmux? is it like choosing a text editor?

Basic commands for `screen` and `tmux` below. They both have keyboard shortcuts as well ([screen cheat sheet](https://training.nih-cfde.org/en/latest/General-Tools/Cheat-Sheets/screen_cheatsheet.html)).

Description | screen | tmux
--- | --- | ---
start a screen session | `screen -S <session name>` | `tmux new -s <session name>`
close a session | `screen -d <session name>` | `tmux detach`
go to existing session | `screen -r <session name>` | `tmux attach -t <session name>`
list existing sessions | `screen ls`  | `tmux ls`
end session | `exit`  | `tmux kill-session -t <session name>`




## Concluding thoughts

(reference how today's material will lead into upcoming workshops) - we'll return to the concept of using scripts to execute/document analysis workflows in workshops 9 (Snakemake) and 10 (Using SLURM on HPC)

* break the task down into multiple commands
* put commands things in shell scripts, run in serial
* use intermediate i/o files to figure out what's going on!
* use echo to debug!

(But we'll also teach you another way to do automation with snakemake.)






## Appendix: exercise answers

*Answers for `set -e` exercises*

1. Fails on 1st iteration with `set -e`, fails each iteration of the loop without `set -e`

Output with `set -e`:

```
(base) ~$ bash set_e.sh
./data/MiSeq/F3D0_S188_L001_R1_001.fastq
Specified output directory 'fastqc_reports' does not exist
```

Output without `set -e`:

```
(base) ~$ bash set_e.sh
./data/MiSeq/F3D0_S188_L001_R1_001.fastq
Specified output directory 'fastqc_reports' does not exist
./data/MiSeq/F3D0_S188_L001_R2_001.fastq
Specified output directory 'fastqc_reports' does not exist
./data/MiSeq/F3D141_S207_L001_R1_001.fastq
Specified output directory 'fastqc_reports' does not exist
./data/MiSeq/F3D141_S207_L001_R2_001.fastq
Specified output directory 'fastqc_reports' does not exist
...
```


2. Add `set -x` option to print out the commands computer is running. There's an error in the path to save FastQC output reports.

```
# wrong path
OUTDIR='fastqc_reports'

# correct path
OUTDIR='./data/fastqc_reports'
```

*Answer for ifs.sh in a loop question*

This is one approach:
```
for i in {18..21}
do
   bash ifs.sh $i 20
done
```

The output will look like this:
```
a is not equal to b!
a is not equal to b!
a is equal to b!
a is not equal to b!
```
